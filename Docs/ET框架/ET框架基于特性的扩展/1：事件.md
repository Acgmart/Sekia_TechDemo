# ET中的事件系统
3个发布事件的例子：
await EventSystem.Instance.PublishAsync(clientScene, new EventType.LoginFinish());
EventSystem.Instance.Publish(clientScene, new EventType.EnterMapFinish());
EventSystem.Instance.Invoke(timerAction.Type, new TimerCallback() { Args = timerAction.Object });

事件分为Public和Invoke两种形式 都有事件的发布者和接收者 都需要用上下文结构体传递信息
Invoke除了上下文还有一个int type表示消息类型 这样一来同一个struct上下文类型可以支持多个Invoke
    比如不同的按钮触发不同的事件 但是上下文结构体一样 type值不一样
Invoke必定有事件的接收者 这里与Public不同
    Public抛出去可以没有订阅 也可以有多个订阅 而Invoke有且只有1个订阅
    Invoke发生在某个模块且高度可预测的情况下 比如UI按钮绑定了一个点击事件
        当用户点击按钮时 传递上下文给接收者 接收者和事件捆绑 要么按钮没有绑定事件
        Invoke避免了使用类Action的委托 在过去的做法是 用户点击按钮时判断委托是否为空并执行委托
        从Invoke替代委托的角度看 Invoke类似于函数 但是函数不方便直接调用 Invoke将事件的定义和行为分开了

# NewOnceTimer/RepeatedTimer
在TimerComponent中使用了Invoke来执行事件函数 使用案例：
self.Timer = TimerComponent.Instance.NewOnceTimer(TimeHelper.ServerNow() + 5000, TimerInvokeType.SessionAcceptTimeout, self);
申请一个定时器并返回定时器的ID 定时器的上下文统一使用了TimerCallback结构体且绑定发布者自身 当触发定时器时通知自身
定时器使用Invoke而不是向过去一样绑定一个lambada表达式 定时器只负责通知目标所以上下文结构统一

# 定义一个Invoke事件
type缺省值是0 上下文类型传递必要的变量
由于Invoke与具体模块挂钩 对应的定义也是放在具体模块下