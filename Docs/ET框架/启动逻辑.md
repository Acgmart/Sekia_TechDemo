# 逻辑入口
使用Init脚本作为整个逻辑系统的入口  
    原则上尽量少使用mono脚本 避免后期积重难返  
    在Init中声明了多个关键的单例 这些单例作为ECS系统的基础设施  
        UnhandledException：处理主线程中未处理的异常  
        MainThreadSynchronizationContext：实现单线程异步  
        TimeInfo/Logger/IdGenerater/EventSystem：底层基础设施
        CoroutineLockComponent：协程锁 使异步任务按顺序执行
        Update/LateUpdate/OnApplicationQuit：系统生命周期
        CodeLoader：初始化逻辑
    CodeLoader：
        EnableCodes：有热更和非热更两种加载模式
            使用ENABLE_CODES预定义后切换为非热更模式
            热更模式下dll打包为code.unity3d
            加载Model和Hotfix后通过反射调用Start方法
        EventSystem.Instance.Add(types)：
            扫描全部Class 通过Attribute对Class进行分类
        ET.Entry.Start()：
            这是Model层的共享代码 执行初始化与抛事件
            NetServices/Root/ConfigComponent：ECS系统基础设施
            事件基于客户端、服务端、双端公共任务分发初始化消息

# DLL依赖关系
ThirdParty ->
Core -> ThirdParty
Mono -> ThirdParty Core
Model -> ThirdParty Core Mono
    机器人需要的数据 不依赖于UnityAPI
ModelView -> ThirdParty Core Mono Model
    真机需要的数据 依赖于UnityAPI
Hotfix -> ThirdParty Core Mono Model
    机器人需要的逻辑 不依赖于Unity库
HotfixView -> ThirdParty Core Mono Model ModelView Hotfix
    真机需要的逻辑 依赖于UnityAPI
Editor -> ThirdParty Core Mono
举例：某个Unit由Hotfix创建 Unit的数据在Model层
    再由HotfixView添加GameObject和Animator等表现组件
    表现组件(GameObject和Animator)等数据在ModelView层
简单的理解为：GamePlay数据层、GamePlay逻辑层、表现数据层、表逻辑现层 

# 订阅回调机制 Invoke
这个机制是游戏开发中非常常见的逻辑 比如点击按钮后执行对应的事件
在这个逻辑中扮演者有：订阅者和服务者 Subscriber and Provider
    预定义了事件逻辑 当事件触发时通知给订阅者并传递事件的上下文
    上下文中描述了事件关联信息 如点击坐标和被点击的物体
在ET中使用Invoke来完成这个逻辑：
    定义事件：AInvokeHandler和InvokeAttribute
    订阅事件：保存事件的type值和struct类型
        可以通过type的字段名或者struct的类名来描述事件的意图
    执行事件：EventSystem.Instance.Invoke
执行事件时 先取出上下文struct对应的事件列表 再寻找type值对应的事件
    相同的上下文可以对应多种事件 就比如点击UI可以触发多种逻辑
    InvokeAttribute的type值默认为0 

# ConfigComponent
初始化：
    获取所有带ConfigAttribute的Class集合
    执行GetAllConfigBytes事件
        Editor模式下：读取Unity外Config目录下的bytes文件
        线上模式下：加载config.unity3d
        每张表格都对应一个byte[]和configType.Name
    多线程异步反序列化byte[]
        Task.WhenAll：等待所有的异步任务全部完成时返回
        LoadOneInThread：反序列化一个表格类型
            表格类型都是单例
 表格修改与打包：   
    ExcelExporter：编辑器工具 调用第三方dll生成表格关联数据
        编译Share/Tool/Share.Tool.csproj生成Tool.exe
        安装.net6 runtime后可运行Tool.exe
        可按项目需求扩展表格导出工具
    表格源文件目录：Assets/Config/Excel
    客户端-表格Bundle生成目录：Assets/Bundle/Config
        Unity打包后生成config.unity3d
    服务端-表格bytes生成目录：Unity外/Config/Excel
        在Editor模式下客户端也可以读取服务端的表格数据
    表格Json生成目录：Assets/Config/Excel/Json
        相比bytes文件Json具有人工可读性 可方便debug
    在表格中新增或修改字段后导出表格将修改对应Model层cs文件
减少加载卡顿：
    如果表格数据太多必然使初次打开应用的卡顿感明显
    可考虑按访问延迟加载或按分类加载 扩展GetOneConfigBytes等逻辑
    服务端启动无需担心延迟 使用同步方法加载即可

# ECS节点系统
ECS系统维护一个组件树结构 组件之间通过父子关系链传递逻辑
为了简化开发ET中并没强调Entity和Component的区别
    比如玩家管理组件负责管理全部玩家 表现上倾向于Component
    玩家可以挂载移动组件、攻击组件 表现上倾向于Entity
    不强调Component后 Entity将同时扮演数据和功能组件
客户端多个根节点：
    GameScene：全局基础组件
    ClientScene：玩家全局业务组件按需添加
    CurrentScene：当前场景相关组件按需添加

# ResourcesComponent
用于客户端加载管理bundle资源 比如读表、加载UI
ResourcesComponent属于全局业务基础设施 挂点在GameScene

# GlobalComponent
用于保存全局表现属性 比如UI挂点、角色模型挂点等
相对于放在业务组件上的属性来说 全局组件的属性公开可访问且有固定初始化逻辑
可以将多个系统都有依赖的属性定义为全局属性 并分类管理

