# 概述
ET作为ECS类型的框架会包含成吨的业务和功能组件。
    会产生树状的数据结构。
所以需要记住有哪些组件，组件之间关系，组件被挂载的位置。
良好的规划可以减少搜索确认的步骤，加快迭代效率，减少心智负担。

# Model/Hotfix/ModelView/HotfixView
ET的主要观点是数据与逻辑分离，基于ECS理念，但是并不严格区分Entity和Component。
Model层表示逻辑概念上的数据，比如HP值。
Hotfix层表示操作Model层数据的逻辑，可以控制HP值的增减。
ModelView表示Model层的表现数据，比如血条UI。
HotfixView层表示ModelView层数据的逻辑，可以控制血条UI动画。

Model层和ModelView层都是数据，但是ModelView的数据包含很多渲染方面的资源。
对于服务端进程和机器人玩家进程来说，就不需要ModelView层，他们只做逻辑层运算。
不同引擎的类库不同，导致ModelView的实现不太一样，但是我们一般都能平替。
    Model层则不会受到引擎的影响。

Hotfix和HotfixView的情况和前者类似，不带View的是底层逻辑，带View的是表现层逻辑。
Hotfix开头也意味着它们支持热更新，热更新只更新逻辑而不更新数据。

# 1.启动层
简单来说就是通过Init脚本作为入口，完成ET的初始化。
ET的初始化方式在历代版本中变化的非常频繁，所以笔记中写具体的代码非常容易过时。
但是还是得写，这里简单记录一下思路：
首先，我们初始化的目标是为了实现一个环境，可以自由添加Entity，然后抛事件或者发消息。
    Entity有自己生命周期，如Awake、Start、Update、Distroy等。
    初始化中的每一个步骤都是为了这个大目标而服务的。
其次呢，很多功能组件之间是有依赖关系的，所以要注意初始化的顺序。
    比如新增一个Enitity需要IdGenerater，而IdGenerater又需要TimeInfo。
    那些没有任何依赖项的功能组件就可以先初始化。
很多功能组件类似于单例对象，我们就可以将他们从Enitity类型变为单例类型(ASingleton)。
    单例对象没有父子层级关系，可以快捷访问。
    为了统一管理这些单例对象，我们用World.Instance来集中管理他们的初始化与销毁。
    考虑到某些单例对象之间也有依赖关系，那么它们的销毁需要遵循后入先出的原则。
宏定义ENABLE_DLL：DLL是否跟随客户端EXE打包
    开启后，将加载打包后的DLL文件，而不是基于本地代码实时编译得到的DLL。
    可以通过这种方式将美术工作人员的工作目录简化，美术不需要被代码报错打断工作。

# 2.单例层



# 3.Fiber层
